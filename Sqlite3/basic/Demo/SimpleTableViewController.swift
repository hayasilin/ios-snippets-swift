//
//  FirstViewController.swift
//  Demo
//
//  Created by user on 2024/03/04.
//

import UIKit
import SQLite3

/// Reference
/// https://juejin.cn/post/6844903822003814413
struct Porudct {
    let id: Int
    let name: String
    let weight: Int
    let price: Double
}

final class SimpleTableViewController: UIViewController {
    private lazy var tableView: UITableView = {
        let tableView = UITableView(frame: .zero)
        tableView.delegate = self
        tableView.dataSource = self
        tableView.estimatedRowHeight = 44
        tableView.rowHeight = UITableView.automaticDimension
        tableView.register(UITableViewCell.self, forCellReuseIdentifier: String(describing: UITableViewCell.self))
        return tableView
    }()

    private lazy var searchController = UISearchController(searchResultsController: nil)

    private var isSearchBarEmpty: Bool {
        searchController.searchBar.text?.isEmpty ?? true
    }

    private var isFiltering: Bool {
        searchController.isActive && !isSearchBarEmpty
    }

    private var products = [Porudct]()
    private var filteredProducts = [Porudct]()

    private var db: OpaquePointer?

    override func viewDidLoad() {
        super.viewDidLoad()
        view.backgroundColor = .systemBackground
        navigationItem.title = "First"
        navigationItem.rightBarButtonItems = [
            UIBarButtonItem(barButtonSystemItem: .add, target: self, action: #selector(presentInsertAlert))
        ]

        tableView.translatesAutoresizingMaskIntoConstraints = false
        view.addSubview(tableView)

        NSLayoutConstraint.activate([
            tableView.topAnchor.constraint(equalTo: view.topAnchor),
            tableView.leadingAnchor.constraint(equalTo: view.safeAreaLayoutGuide.leadingAnchor),
            tableView.trailingAnchor.constraint(equalTo: view.safeAreaLayoutGuide.trailingAnchor),
            tableView.bottomAnchor.constraint(equalTo: view.bottomAnchor)
        ])

        configureSearchController()

        db = configureDatabase()
        createTable()
        queryProducts()

        if products.isEmpty {
            insertAutoGeneratedProducts()
        }

        tableView.reloadData()

        let refreshControl = UIRefreshControl()
        refreshControl.addTarget(self, action: #selector(refreshData), for: .valueChanged)
        tableView.refreshControl = refreshControl
    }

    private func configureSearchController() {
        searchController.searchResultsUpdater = self
        searchController.obscuresBackgroundDuringPresentation = false
        searchController.searchBar.placeholder = "Search..."
        navigationItem.searchController = searchController
        definesPresentationContext = true
    }

    private func configureDatabase() -> OpaquePointer? {
        guard let libraryPath = NSSearchPathForDirectoriesInDomains(.libraryDirectory, .userDomainMask, true).first else {
            assertionFailure("Configure database failure")
            return nil
        }

        let libraryURL = URL(fileURLWithPath: libraryPath).appendingPathComponent("product.sqlite")
        let databasePath = libraryURL.path

        var db: OpaquePointer?
        if sqlite3_open(databasePath, &db) == SQLITE_OK {
            // It creates a database if it doesn't exist or open database if exist.
            print("Open database success: \(databasePath)")
            return db
        } else {
            assertionFailure("Configure database failure")
            return nil
        }
    }

    func createTable() {
        let sqlQueryString = """
                            CREATE TABLE IF NOT EXISTS products(
                            id INT PRIMARY KEY NOT NULL,
                            name CHAR(255),
                            weight Int,
                            price Float
                            );
                            """
        var statement: OpaquePointer?

        if sqlite3_prepare_v2(db, sqlQueryString, -1, &statement, nil) == SQLITE_OK {
            if sqlite3_step(statement) == SQLITE_DONE {
                print("Create table success")
            } else {
                logSQLErrorMessage()
            }
        } else {
            logSQLErrorMessage()
        }
        // 每次操作完成都需使用來刪除statement以避免resource leak，注意一旦finalized後就不該再去使用它
        sqlite3_finalize(statement)
    }

    private func queryProducts() {
        products.removeAll()

        let queryString = "SELECT * FROM products;"
        var queryStatement: OpaquePointer?

        guard sqlite3_prepare_v2(db, queryString, -1, &queryStatement, nil) == SQLITE_OK else {
            logSQLErrorMessage()
            return
        }

        while sqlite3_step(queryStatement) == SQLITE_ROW {
            let id = sqlite3_column_int(queryStatement, 0)
            let name = String(describing: String(cString: sqlite3_column_text(queryStatement, 1)))
            let weight = sqlite3_column_int(queryStatement, 2)
            let price = sqlite3_column_double(queryStatement, 3)

            products.append(
                Porudct(
                    id: Int(id),
                    name: name,
                    weight: Int(weight),
                    price: price
                )
            )
        }

        sqlite3_finalize(queryStatement)
    }

    func insertAutoGeneratedProducts() {
        for index in 1...5 {
            products.append(
                Porudct(
                    id: index,
                    name: "auto-generated product" + "\(index)",
                    weight: index * 10,
                    price: 20.0 * Double(index)
                )
            )
        }

        let sqlQueryString = "INSERT INTO products(id, name, weight, price) VALUES (?, ?, ?, ?);"
        var insertStatement: OpaquePointer?

        if sqlite3_prepare_v2(db, sqlQueryString, -1, &insertStatement, nil) == SQLITE_OK {
            for (index, product) in products.enumerated() {

                let id: Int32 = Int32(index + 1)
                sqlite3_bind_int(insertStatement, 1, id)

                // sqlite3_bind_text函數比其他多2個參數，說明如下：
                // 第一個參數是你的statement
                // 第二個參數是你的statement裡面的?的順序
                // 第三個參數是想給?的值
                // 第四個參數是text的字節數，一般給-1
                // 第五個參數是closure callback，處理完String後使用
                sqlite3_bind_text(insertStatement, 2, (product.name as NSString).utf8String, -1, nil)

                sqlite3_bind_int(insertStatement, 3, Int32(product.weight))

                sqlite3_bind_double(insertStatement, 4, product.price)

                if sqlite3_step(insertStatement) == SQLITE_DONE {
                    print("Insert product \(product.id) success")
                } else {
                    logSQLErrorMessage()
                }
                // 使用sqlite3_reset以便下次迴圈再次執行statement
                sqlite3_reset(insertStatement)
            }
        } else {
            logSQLErrorMessage()
        }
        sqlite3_finalize(insertStatement)
    }

    func insert(_ product: Porudct) {
        let insertRowString = "INSERT INTO products(id, name, weight, price) VALUES (?, ?, ?, ?);"
        var insertStatement: OpaquePointer?

        if sqlite3_prepare_v2(db, insertRowString, -1, &insertStatement, nil) == SQLITE_OK {
            sqlite3_bind_int(insertStatement, 1, Int32(product.id))

            // sqlite3_bind_text函數比其他多2個參數，說明如下：
            // 第一個參數是你的statement
            // 第二個參數是你的statement裡面的?的順序
            // 第三個參數是想給?的值
            // 第四個參數是text的字節數，一般給-1
            // 第五個參數是closure callback，處理完String後使用
            sqlite3_bind_text(insertStatement, 2, (product.name as NSString).utf8String, -1, nil)

            sqlite3_bind_int(insertStatement, 3, Int32(product.weight))

            sqlite3_bind_double(insertStatement, 4, product.price)

            if sqlite3_step(insertStatement) == SQLITE_DONE {
                products.append(product)
                tableView.reloadData()
            } else {
                logSQLErrorMessage()
            }
        } else {
            logSQLErrorMessage()
        }

        sqlite3_finalize(insertStatement)
    }

    func updateProduct(name: String, at index: Int) {
        let sqlQueryString = "UPDATE products SET name = ? WHERE id = ?;"
        var statement: OpaquePointer?

        if sqlite3_prepare_v2(db, sqlQueryString, -1, &statement, nil) == SQLITE_OK {

            sqlite3_bind_text(statement, 1, (name as NSString).utf8String, -1, nil)
            sqlite3_bind_int(statement, 2, Int32(index))

            if sqlite3_step(statement) == SQLITE_DONE {
                print("Update success")
            } else {
                logSQLErrorMessage()
            }
        } else {
            logSQLErrorMessage()
        }

        sqlite3_finalize(statement)
    }

    func deleteProduct(with id: Int) {
        let sqlQueryString = "DELETE FROM products WHERE id = ?;"
        var statement: OpaquePointer?

        if sqlite3_prepare_v2(db, sqlQueryString, -1, &statement, nil) == SQLITE_OK {

            sqlite3_bind_int(statement, 1, Int32(id))

            if sqlite3_step(statement) == SQLITE_DONE {
                print("Delete success")
            } else {
                logSQLErrorMessage()
            }
        } else {
            logSQLErrorMessage()
        }

        sqlite3_finalize(statement)
    }

    func searchProduct(with name: String) {
        filteredProducts.removeAll()

        let queryString = "SELECT * FROM products WHERE name LIKE '%\(name)%';"
        var statement: OpaquePointer?

        if sqlite3_prepare_v2(db, queryString, -1, &statement, nil) == SQLITE_OK {

            while sqlite3_step(statement) == SQLITE_ROW {
                let id = sqlite3_column_int(statement, 0)
                let name = String(describing: String(cString: sqlite3_column_text(statement, 1)))
                let weight = sqlite3_column_int(statement, 2)
                let price = sqlite3_column_double(statement, 3)

                filteredProducts.append(
                    Porudct(
                        id: Int(id),
                        name: name,
                        weight: Int(weight),
                        price: price
                    )
                )
            }
        }

        sqlite3_finalize(statement)
    }

    @objc
    func presentInsertAlert(_ sender: UIBarButtonItem) {
        let alert = UIAlertController(title: nil, message: "Insert a product", preferredStyle: .alert)
        alert.addTextField()
        alert.textFields?.first?.placeholder = "Product name"

        let action = UIAlertAction(title: "Save", style: .default) { _ in
            guard let name = alert.textFields?.first?.text else {
                return
            }
            let product = Porudct(
                id: (self.products.last?.id ?? 0) + 1,
                name: name,
                weight: 100,
                price: 2000.0
            )
            self.insert(product)
        }
        alert.addAction(action)

        present(alert, animated: true)
    }

    private func logSQLErrorMessage() {
        let errorMessage = String(cString: sqlite3_errmsg(db))
        print("SQL error: \(errorMessage)")
    }

    @objc
    private func refreshData(_ sender: UIRefreshControl) {
        queryProducts()
        tableView.refreshControl?.endRefreshing()
    }
}

extension SimpleTableViewController: UITableViewDataSource {
    func tableView(_ tableView: UITableView, numberOfRowsInSection section: Int) -> Int {
        isFiltering ? filteredProducts.count : products.count
    }
    
    func tableView(_ tableView: UITableView, cellForRowAt indexPath: IndexPath) -> UITableViewCell {
        let cell = tableView.dequeueReusableCell(withIdentifier: String(describing: UITableViewCell.self), for: indexPath)

        let computer: Porudct
        if isFiltering {
            computer = filteredProducts[indexPath.row]
        } else {
            computer = products[indexPath.row]
        }

        cell.textLabel?.text = computer.name
        return cell
    }
}

extension SimpleTableViewController: UITableViewDelegate {
    func tableView(_ tableView: UITableView, didSelectRowAt indexPath: IndexPath) {
        tableView.deselectRow(at: indexPath, animated: true)

        var product: Porudct
        if isFiltering {
            product = filteredProducts[indexPath.row]
        } else {
            product = products[indexPath.row]
        }

        let alert = UIAlertController(title: nil, message: "Update product name", preferredStyle: .alert)
        alert.addTextField()
        alert.textFields?.first?.placeholder = product.name

        let action = UIAlertAction(title: "Update", style: .default) { _ in
            guard let name = alert.textFields?.first?.text else {
                return
            }
            self.updateProduct(name: name, at: product.id)
            self.products[indexPath.row] = Porudct(
                id: product.id,
                name: name,
                weight: product.weight,
                price: product.price
            )
            self.tableView.reloadRows(at: [indexPath], with: .automatic)
        }
        alert.addAction(action)

        present(alert, animated: true)
    }

    func tableView(_ tableView: UITableView, trailingSwipeActionsConfigurationForRowAt indexPath: IndexPath) -> UISwipeActionsConfiguration? {
        let deleteAction = UIContextualAction(style: .destructive, title: "Delete") { contextualAction, view, complete in
            guard contextualAction.style == .destructive else {
                complete(false)
                return
            }
            let computer = self.products[indexPath.row]
            self.products.remove(at: indexPath.row)
            self.deleteProduct(with: computer.id)
            tableView.deleteRows(at: [indexPath], with: .automatic)
            complete(true)
        }
        deleteAction.backgroundColor = .red
        return UISwipeActionsConfiguration(actions: [deleteAction])
    }
}

extension SimpleTableViewController: UISearchResultsUpdating {
    func updateSearchResults(for searchController: UISearchController) {
        guard let searchText = searchController.searchBar.text, !searchText.isEmpty else {
            queryProducts()
            tableView.reloadData()
            return
        }

//        filteredProducts = products.filter { computer -> Bool in
//            computer.name.lowercased().contains(searchText.lowercased())
//        }

        searchProduct(with: searchText.lowercased())
        tableView.reloadData()
    }
}
